---
layout:     post
title:      "[SCOI2012]奇怪的游戏"
date:       2018-03-16
author:     "DieSheep"
header-img: "img/6.jpg"
catalog: true
tags:
    - 网络流
    - 二分答案
---
# [题目](http://www.lydsy.com/JudgeOnline/problem.php?id=2756)

## Description

Blinker最近喜欢上一个奇怪的游戏。这个游戏在一个<strong>N*M</strong>的棋盘上玩，每个格子有一个数。
每次Blinker会选择两个相邻的格子，并使这两个数都加上 1。
现在Blinker想知道最少多少次能使棋盘上的数都变成同一个数，如果永远不能变成同一个数则输出-1。

## Input
输入的第一行是一个整数T，表示输入数据有T轮游戏组成。

每轮游戏的第一行有两个整数N和M，分别代表棋盘的行数和列数。

接下来有N行，每行M个数。

## Output

对于每个游戏输出最少能使游戏结束的次数，如果永远不能变成同一个数则输出-1。

### Sample Input

<strong>2</strong>

<strong>2 2</strong>

<strong>1 2</strong>

<strong>2 3</strong>

<strong>3 3</strong>

<strong>1 2 3</strong>

<strong>2 3 4</strong>

<strong>4 3 2</strong>

### Sample Output

<strong>2</strong>

<strong>-1</strong>

## HINT

### 【数据范围】 

对于30%的数据，保证T<=10，1<=N,M<=8 

对于100%的数据，保证T<=10，1<=N,M<=40，所有数为正整数且小于1000000000

由于每次选择的两个格子都是相邻的，所以我们考虑黑白染色

设黑格子里的数的总和为<strong>*sum0*</strong>，白格子里的数的总和为<strong>*sum1*</strong>，黑格子有<strong>*tot0*</strong>个，白格子有<strong>*tot1*</strong>个

分类讨论：

- 若sum0!=sum1

假设最后每个格子里的数都是<strong>*ans*</strong>

则有

<strong>*ans* * *sum0-tot0=ans* * *sum1-tot1*</strong>

即

<strong>*ans=(tot0-tot1)/(sum0-sum1)*</strong>

然而我们还需要检验一下ans的正确性（如果不可能所有格子一样ans的假设不成立）

首先一定有ans>=max{原先格子值}~~不然你怎么操作~~

考虑网络流，源点向黑格子连边，容量为ans-原先格子的值（补成ans需要加多少），白格子向汇点连边，容量也为ans-原先格子的值

然后每个黑格子向ta相邻的白格子连边，容量为inf

如果最大流的答案=<strong>ans*sum0-tot0</strong>，说明成立

- 若sum0=sum1

这就相当于拿1*2大小的方块覆盖原图
