---
layout:     post
title:      "2018SD省选题解（dalao勿进）"
date:       2018-04-09
author:     "DieSheep"
header-img: "img/19.jpg"
catalog: true
tags:
    - 题解
---
虽然我省选考的炸的一匹。。。但还是得~~厚颜无耻~~尽心尽力的肝完这些题写一下题解嘛。。。

由于本蒟蒻方法低下+常数巨大，所以似乎每个题都是恰好卡过去的。。。dalao不要吐槽

题目就不放了。。。

# Day2
## T1
emmmm。。。这道题其实思路挺简单的。。。~~我还肝了一天~~

按编号遍历每个人，再按志愿从小到大遍历志愿，动态加边并判断加上后最大流是否=1

是就退出，不是就拆下加上的边并向下遍历

这是第一问，第二问一看就可以二分答案

每次二分调换一下再判断就行了

这里有个优化：因为二分每次都重建边很麻烦，可以存0~n-1最优情况下的图，然后二分判断就可以直接在前一个图上面加边

拆边也是个优化，但本蒟蒻不知道领接表的拆边怎么写吗，于是就用了vector。。。

考试的时候有一个奇葩的贪心网络流，感觉能得60+，结果脑抽加了一句这个志愿没出现过就输出i，然后只有10分。。。

代码（丑的一匹）：
```
# include<iostream>
# include<cstring>
# include<cstdio>
# include<queue>
# include<vector>
using namespace std;
const int MAX=201,MAXN=602,inf=1e8;
struct p{
	int y,dis,fl;
};
vector<p> c[MAX<<3],cc[MAX<<3][MAX<<3];
int T,C,n,m,t;
int s[MAX],d[MAXN],b[MAX],ans[MAX];
int gh[MAX][MAX];
int a[MAX][MAX][MAX];
int read()
{
	int x=0,f=1;
	char ch=getchar();
	for(;!isdigit(ch);f=(ch=='-')?-1:1,ch=getchar());
	for(;isdigit(ch);x=x*10+ch-48,ch=getchar());
	return x*f;
}
void add(int x,int y,int dis)
{
	c[x].push_back((p){y,dis,c[y].size()});
	c[y].push_back((p){x,0,c[x].size()-1});
}
void cut(int x)
{
	c[x].pop_back();
}
bool bfs()
{
	queue<int> qu;
	qu.push(0);
	memset(d,0,sizeof(d));
	d[0]=1;
	while(!qu.empty())
	{
		int tt=qu.front();
		qu.pop();
		for(int i=0;i<c[tt].size();++i)
		  if(!d[c[tt][i].y]&&c[tt][i].dis)
		  {
		  	d[c[tt][i].y]=d[tt]+1;
		  	qu.push(c[tt][i].y);
		  }
	}
	return d[t];
}
int dfs(int x,int dix)
{
	if(x==t||!dix) return dix;
	int sum=0;
	for(int i=0;i<c[x].size();++i)
	  {
	  	int y=c[x][i].y,fl=c[x][i].fl;
	  	if(d[y]==d[x]+1&&c[x][i].dis)
		{
		  	int dis=dfs(y,min(dix,c[x][i].dis));
	  		if(dis)
	  		{
	  			sum+=dis;
	  			dix-=dis;
	  			c[x][i].dis-=dis;
	  			c[y][fl].dis+=dis;
	  			if(!dix) break;
			}
	  	}
	  }
	if(!sum) d[x]=-1;
	return sum;
}
int dinic()
{
	int tot=0;
	while(bfs()) tot+=dfs(0,inf);
	return tot;
}
void work()
{
	for(int i=1;i<=n;++i)
	  {
	  	bool fl=0;
	  	for(int j=1;j<c[i].size();++j)
	  	  if(c[c[i][j].y][c[i][j].fl].dis)
	  	  {
	  	  	fl=1;
	  	  	printf("%d ",(ans[i]=gh[i][c[i][j].y-n]));
	  	  	break;
		  }
		if(!fl) printf("%d ",m+1);
	  }
	printf("\n");
}
bool Work(int mid)
{
	for(int i=1;i<c[mid].size();++i)
	  if(c[mid][i].dis)
	  if(gh[mid][c[mid][i].y-n]<=s[mid]) return 1;
	  else return 0;
}
bool look(int mid)
{
	for(int i=0;i<=2*n+m;++i)
	  c[i]=cc[mid-1][i];
	c[t]=cc[mid-1][t];
	for(int j=1;j<=s[mid];++j)
	  if(a[mid][j][0])
	  {
	  	for(int l=1;l<=a[mid][j][0];++l)
	  	  add(mid,a[mid][j][l]+n,1);
	  	int tot=dinic();
	  	if(tot==1) return 1;
		for(int l=1;l<=a[mid][j][0];++l)
		  cut(a[mid][j][l]+n),cut(mid);
	  }
	return 0;
}
void Copy(int x)
{
	for(int i=0;i<=2*n+m;++i)
	  cc[x][i]=c[i];
	cc[x][t]=c[t];
}
int main()
{
	T=read(),C=read();
	while(T--)
	{
		n=read(),m=read();
		t=n*2+m+1;
		memset(ans,1,sizeof(ans));
		memset(a,0,sizeof(a));
		memset(c,0,sizeof(c));
		memset(cc,0,sizeof(cc));
		for(int i=1;i<=m;++i)
		  add(i+n,i+n+m,(b[i]=read())),add(i+n+m,t,inf);
		for(int i=1;i<=n;++i)
		  add(0,i,1);
		Copy(0);
		for(int i=1;i<=n;++i)
		  {
		  	for(int j=1;j<=m;++j)
		  	  a[i][(gh[i][j]=read())][++a[i][gh[i][j]][0]]=j;
			for(int j=1;j<=m;++j)
		  	  if(a[i][j][0])
			  {
		  	  	for(int l=1;l<=a[i][j][0];++l)
		  	  	  add(i,a[i][j][l]+n,1);
		  	  	int tot=dinic();
		  	  	if(tot==1) break;
		  	  	for(int l=1;l<=a[i][j][0];++l)
		  	  	  cut(a[i][j][l]+n),cut(i);
			  }
			Copy(i);
		  }
		for(int i=1;i<=n;++i)
		  s[i]=read();
		work();
		for(int i=1;i<=n;++i)
		  {
		  	if(ans[i]<=s[i]) printf("0 ");
		  	else
		  	{
		  		int l=1,r=i-1,Ans=-1;
		  		while(l<=r)
		  		{
		  			int mid=(l+r>>1);
		  			swap(a[i],a[i-mid]);
		  			swap(s[i],s[i-mid]);
		  			if(look(i-mid)) Ans=mid,r=mid-1;
		  			else l=mid+1;
		  			swap(a[i],a[i-mid]);
		  			swap(s[i],s[i-mid]);
				}
				if(Ans!=-1) printf("%d ",Ans);
				else printf("%d ",i);
			}
		  }
		printf("\n");
	}
	return 0;
}
```
